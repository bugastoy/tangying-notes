##### ECMAScript 6简介

1. ECMAScript和JavaScript的关系
   - 前者是后者的规格，后者是前者的一种实现。日常场合这两个词可以替换。
2. ES6和ES2015的关系
   - 2011年，ECMSAScript5.1版发布后，开始制定6.0版。因此，ES6原意是指JavaScript语言的下一个版本。
   - ES6既是一个历史名词，也是一个泛指，含义是5.1版以后的JavaScript的下一代标准，涵盖了ES2015、ES2016、ES2017等等，而ES2015则指正式名称，特质该年发布的正式版本的语言标准。

##### Babel转码器

- Babel是一个广泛使用的ES6转码器，可以将ES6转为ES5代码，从而在老版本的浏览器执行。

##### let命令

- 基本用法

  - 用法类似var，但是let声明的变量只在它所在的代码块有效。

  - let适用于for循环，for循环有一个特别之处，设置循环变量的部分是一个父作用域，而循环体内部是一个单独的子作用域。

    1. `var a = [];`
    2. `for (let i = 0; i < 10; i++) {`
    3. `  a[i] = function () {`
    4. `    console.log(i);`
    5. `  };`
    6. `}`
    7. `a[6](); // 6`

    以上代码中，变量i是let声明的，当前的i只在本轮循环有效，因此每一次循环的i其实都是一个新的变量。

    如何计算出本轮循环的值：JavaScript引擎内部会记住上一轮循环的值，在初始化本轮的变量i时，就在上一轮的基础上进行计算。

- 不存在变量提升

  - var命令存在变量提升，即变量可以在声明之前使用，值为undefined。
  - let命令所声明的变量一定要在声明后使用，否则报错。
    1. `// var 的情况`
    2. `console.log(foo); // 输出undefined`
    3. `var foo = 2;`
    4. ``
    5. `// let 的情况`
    6. `console.log(bar); // 报错ReferenceError`
    7. `let bar = 2;`

- 暂时性死区（TDZ）

  - 只要块级作用域内存在let命令，那么它所声明的变量就“绑定”这个区域，不再受外界影响。
  - ES6明确规定。如果在区块中存在let和const命令，这个区块对这些命令声明的变量，从一开始就形成了一个封闭作用域。凡是在声明前使用这些变量，就会报错。
  - 总之，在代码块内，使用let命令声明变量之前，该变量都是不可用的。
  - 在没有let之前，typeof运算符是百分百安全的，永远不会报错。因此在使用变量前一定要声明，否则会报错。
    1. `typeof x; // ReferenceError`
    2. `let x;`
  - 下面代码报错，也是因为暂时性死区，使用let声明变量x的语句还没有执行完成，就去取x的值，就会导致报错“未定义”
    1. `// 不报错`
    2. `var x = x;`
    3. ``
    4. `// 报错`
    5. `let x = x;`
    6. `// ReferenceError: x is not defined`

- 不允许重复声明

  - let不允许在同一个作用域内重复声明一个变量。因此，不能在函数内部重新声明参数。

##### 块级作用域

- 为什么需要块级作用域
  - ES5只有全局作用域和局部作用域，没有块级作用域，带来了很多不合理场景。
    - 场景一：内层变量可能会覆盖外层变量
    - 场景二：用来计数的循环变量泄露为全局变量
- ES6的块级作用域
  - ES6允许块级作用域的任意嵌套。
  - 内层作用域可以定义外层作用域的同名变量
  - 块级作用域的出现，使得匿名立即执行函数表达式（IIFE）不再必要了。
- 块级作用域与函数声明
  - ES6明确允许在块级作用域之中声明函数。
  - 函数声明语句的行为类似var，即会提升到全局作用域或函数作用域的头部。
  - 同时，函数声明还会提升到所在的块级作用域的头部
  - 注意，上面三条规则只对支持ES6的浏览器实现有效，其他环境还是将块级作用域的函数声明当作let处理。
  - 另外，ES6的块级作用域必须有大括号，如果没有大括号，JavaScript引擎就认为不存在块级作用域。

##### const命令

- 基本用法
  - const声明一个只读的常量。一旦声明，常量的值就不能改变。因此，const一旦声明变量，就必须立即初始化，不能留到以后赋值。
  - const的作用域与let命令相同：只在声明所在的块级作用域内有效。
  - const声明的常量 也是不提升，同样存在暂时性死区，只能在声明的位置后使用。
  - const声明的常量，也与let一样不可重复声明。
  - 注意：let定义变量，const定义常量。
- 本质
  - const实际上保证的，不是变量的值不得改动，而是变量指向的那个内存地址所保存的数据不得改动。
  - 对于简单类型的数据（数值、字符串、布尔值），值就保存在变量指向的那个内存地址，因此等同于常量。对于复杂数据类型的数据（对象、数组），变量指向的内存地址，保存的是指向实际数据的指针，const只能保证这个指针是固定的（即它总是指向另一个固定的地址），至于它指向的数据结构是否可变，就完全不能控制了。
  - Object.freeze方法可以将对象冻结，像对象里面添加新属性不起作用，严格模式时还会报错。
- ES6声明变量的六种方法
  - var、function、let、const、import、class

##### 顶层对象的属性

- 顶层对象，在浏览器环境指的是window对象，在Node指的是global对象。ES5之中，顶层对象的属性与全局变量是等价的。
- ES6为了保持兼容性，规定var、function命令声明的全局变量，依旧是顶层对象的属性；另一方面规定，let、const、class声明的全局变量不属于顶层对象的属性。

##### globalThis对象

- 在任何环境下，globalThis都存在，都可以从它拿到顶层对象，指向全局环境的this。

##### 数组的解构赋值

- ES6允许按照一定模式，从数组和对象中提取值，对变量进行赋值，称为解构。

- 对于set结构，也可以数组的解构赋值。
  1. `let [x, y, z] = new Set(['a', 'b', 'c']);`

- 只要某种数据结构具有Iterator接口，都可以采用数组形式的解构赋值。


- 解构赋值允许指定默认值。默认值可以引用解构赋值的其他变量，但该变量必须已经声明。


##### 对象的解构赋值

1. 简介
   - 对象的解构赋值可以很方便地将现有对象的方法，赋值到某个变量。
     1. `// 例一`
     2. `let { log, sin, cos } = Math;`
     3. / /将Math对象的对数、正弦、余弦三个方法赋值到对应的变量上
     4. `// 例二`
     5. `const { log } = console;`
     6. `log('hello') // hello`
   - 对象的解构赋值是下面形式的简写。
     1. `let { foo: foo, bar: bar } = { foo: 'aaa', bar: 'bbb' };`
   - 对象的解构赋值的内部机制，是先找到同名属性，再赋给对应的变量。真正被赋值的是后者。
   - 注意：对象的解构赋值可以取到继承的属性。
2. 默认值
   - 对象的解构也可以指定默认值。默认值生效的条件是，对象的属性值严格等于undefined。

##### 字符串的解构赋值

1. 字符串解构赋值时，会被转换成了一个类似数组的对象。
2. 还可以对length属性解构赋值
   1. `let {length : len} = 'hello';`
   2. `len // 5`

##### 数值和布尔值的解构赋值

1. 解构赋值时，如果等号右边是数值和布尔值，则会先转为对象。
   1. `let {toString: s} = 123;`
   2. `s === Number.prototype.toString // true`
   3. `let {toString: s} = true;`
   5. `s === Boolean.prototype.toString // true`
2. undefined会触发函数参数的默认值

##### 圆括号问题

- 以下三种解构赋值不得使用圆括号
  - 变量声明语句
  - 函数参数
  - 赋值语句的模式

- 可以使用圆括号的情况：赋值语句的非模式部分
  1. `[(b)] = [3]; // 正确`
  2. `({ p: (d) } = {}); // 正确`
  3. `[(parseInt.prop)] = [3]; // 正确`

##### 用途

- 交换变量的值

  ```
  let x = 1;
  let y = 2;
  [x, y] = [y, x];
  ```

- 从函数返回多个值

  - 在之前，函数只能返回一个值，如果要返回多个值，只能把它们放在数组或炸对象中。

- 函数参数的定义

  - 解构赋值可以方便地将一组参数与变量名对应起来。

    ```
    // 参数是一组有次序的值
    function f([x, y, z]) { ... }
    f([1, 2, 3]);
    // 参数是一组无次序的值
    function f({x, y, z}) { ... }
    f({z: 3, y: 2, x: 1});
    ```

- 提取JSON数据

- 指定函数参数的默认值

- 遍历Map结构*

  - 任何部署了Iterator接口地对象，都可以用for...of循环遍历。Map结构原生支持Iterator接口，配合变量的解构赋值，获取键名和键值十分方便。

  - 只想获取键名或键值其中一个时，可以写成以下代码

    ```
    // 获取键名
    for (let [key] of map) {
      // ...
    }
    // 获取键值
    for (let [,value] of map) {
      // ...
    }
    ```

- 输入模块的指定方法

```
const { SourceMapConsumer, SourceNode } = require("source-map");
```

##### 字符串的新增方法

- String.fromCodePoint（）
  - 用于从Unicode码点返回对应字符，可以识别大于0xFFFF的字符。
- String.raw（）
  - ES6为原生的String对象，提供了一个raw（）方法。
  - 该方法返回一个斜杠都被转义，往往用于模板字符串的处理方法。

- codePointAt（）
  - 正确处理4个字节储存的字符，返回一个字符的码点。
  - 返回的是码点的十进制，toString（）方法可以准换为码点的十六进制。

- normalize（）
  - 用来将字符的不同表示方法统一为同样的形式，即Unicode正规化

- 确定一个字符串是否包含在另一个字符串的三种方法
  - includes（）：返回布尔值，表示是否找到了参数字符串。
  - startsWith（）：返回布尔值，表示参数字符串是否在原字符串的头部。
  - endsWith（）：返回布尔值，表示参数字符串是否在原字符串的尾部。
  - 三种方法都支持第二个参数，表示开始搜索的位置

- repeat（）
  - 返回一个新字符串，表示将原字符串重复n次。
  - 参数如果是小数的话，会被取整；参数是负数或者Infinity，则会报错。

- padStart（）

  - 用于头部补全，常用于为数值补全指定位数、提示字符串

    ```
    '1'.padStart(10, '0') // "0000000001"
    '12'.padStart(10, 'YYYY-MM-DD') // "YYYY-MM-12"
    ```

- padEnd（）
  - 用于尾部补全。两个方法都是接受两个参数。第一个参数是字符串补全生效的最大长度，第二个参数是用来补全的字符串。

- trimStart（）、trimEnd（）
  - trimStart（）消除字符串头部的空格，trimEnd（）消除尾部的空格。它们返回的都是新字符串，不会修改原始字符串。

##### 正则的扩展

- RegExp构造函数
  - 第一个参数是一个正则对象
  - 第二个参数指定修饰符

- Unicode属性类
  - \p{...}匹配满足条件的字符
  - \P{...}匹配不满足条件的字符

- 具名组匹配
  - 简介：正则表达式使用圆括号进行组匹配

##### rest参数

- ES6引入了rest参数（...变量名），用于获取函数的多余参数。rest参数搭配的变量是一个数组，该变量将多余的参数放入数组中。

- rest就是一个真正的数组，数组特有的方法都可以使用。

- rest参数之后不能再有其他参数，否则报错。

  ```
  // 报错
  function f(a, ...b, c) {}
  ```

- 函数的length属性，不包括rest参数。

  ```
  (function(...a) {}).length  // 0
  ```

##### 箭头函数

- 基本用法

  ```
  var f = v => v;//一个参数
  // 等同于
  var f = function (v) {
    return v;
  };
  var f = () => 5;//没有参数
  var sum = (num1, num2) => num1 + num2;//多个参数
  // 等同于
  var sum = function(num1, num2) {
    return num1 + num2;
  };
  ```

  - 当箭头函数的代码块部分多于一条语句，需用大括号括起来，使用return语句返回。

  - 当箭头函数直接返回一个对象，必须在对象外加括号，否则报错。

    ```
    let getTempItem = id => ({ id: id, name: "Temp" });
    ```

  - 好处：简化回调函数。

- 使用注意点
  - 关于this
    - 函数体内的this对象，就是定义时所在的对象，而不是使用时所在的对象。
    - this对象的指向是可变的，但在箭头函数中，是固定的，这种特性有利于封装回调函数。
    - 除了this，以下三个变量在箭头函数中也不存在，指向外层函数的对应变量：arguments、super、new.target。
    - 箭头函数没有自己的this，因此也不能用call（）、apply（）、bind（）改变this的指向。
  - 不可以当作构造函数，即不可以使用new命令，否则会抛出一个错误。
  - 不可以使用arguments对象，该对象在函数体内不存在。如果要用，可以用rest参数代替。
  - 不可以使用yield命令，因此箭头函数不能用作Generator函数。

- 不适应场合
  - 定义对象的方法，且该方法内部包括this、
  - 需要动态this的时候。

- 嵌套的箭头函数
  - 部署管道机制

##### Set

- 基本用法

  - ES6提供的新的数据结构。类似于数组，但是成员值都唯一，无重复值。

  - Set函数可以接受一个数组（或者具有iterable接口的其他数据结构）作为参数，用来初始化。

  - 去除数组重复成员的方法：

    - set最大一个特点就是元素成员不重复。
    
    1. ```
       [...new Set（array)]
       ```
    
    2. ```
       function dedupe(array) {
         return Array.from(new Set(array));
       }  //Array.from方法可将Set转换成数组
       dedupe([1, 1, 2, 3]) // [1, 2, 3]
       ```

- Set实例的属性和方法
  - 属性
    - Set.prototype.constructr：构造函数，默认就是Set函数
    - Set.prototype.size：返回Set实例的成员总数
  - 方法
    - Set.prototype.add（）：添加某个值，返回Set结构本身
    - Set.prototype.delete（）：删除某个值，返回一个布尔值，表示是否删除成功
    - Set.prototype.has（）：返回一个布尔值，表示该值是否为Set的成员
    - Set.prototype.clear（）：清除所有成员，没有返回值

- 遍历操作

  - Set的遍历顺序就是插入顺序。Set的键名和键值是同一个值。可以直接使用for...of或者扩展运算符（...）遍历Set。

  - Set.prototype.keys（）：返回键名的遍历器

  - Set.prototype.values（）：返回键值的遍历器

  - Set.prototype.entries（）：返回键值对的遍历器

  - Set.prototype.forEach（）：使用回调函数遍历每个成员，没有返回值

  - 在遍历操作中，同步改变Set结构，有以下两种方法

    ```
    // 方法一
    let set = new Set([1, 2, 3]);
    set = new Set([...set].map(val => val * 2));
    // 方法二
    let set = new Set([1, 2, 3]);
    set = new Set(Array.from(set, val => val * 2));
    // set的值是2, 4, 6
    ```

##### WeakSet

- 含义
  - 与Set结构类似，有以下两个区别
    - WeakSet的成员只能是对象 ，不能是其他类型的值。
  - WeakSet适合临时存放一组对象，以及存放跟对象绑定的信息。原因是，WeakSet里面的引用都不计入垃圾回收机制，不会引发内存泄漏。
  - ES6规定WeakSet不可遍历。

- 语法
  - 作为构造函数，WeakSet可以接受一个数组或类似数组的对象作参数，任何具有Iterable接口的对象，都可以作为它的参数。该数组的所有成员，都会自动成为WeakSet实例对象的成员。

- 方法
  - WeakSet.prototype.add（）：像WeakSet实例添加一个新成员
  - WeakSet.prototype.delete（）：清楚WeakSet实例的指定成员
  - WeakSet.prototype.has（）：返回一个布尔值，表示某个值是否在WeakSet实例中
  - 没有size、forEach属性，无法遍历它的成员。

- 用处
  - 储存DOM节点，不用担心节点从文档移除时，发生内存泄漏。

##### Map

- 含义和基本用法

  - ES6提供了Map数据结构。它类似于对象，也是键值对的集合，各种类型的值（包括对象）都可以当作键。

  - 以下代码展示了如何向Map添加成员，使用Map的set方法，将对象o当作m的一个键，然后使用get方法读取这个键。

    ```
    const o = {p: 'Hello World'};
    m.set(o, 'content')
    m.get(o) // "content"
    ```

- 实例的属性和方法
  - size属性
    - 返回Map的成员总数
  - Map.prototype.set(key,value)
  - Map.prototype.get(key)
  - Map.prototype.has(key)
  - Map.prototype.delete(key)
    - 删除某个键，返回true。删除失败，返回false。
  - Map.prototype.clear()

- 遍历方法
  - Map.prototype.keys()：返回键名的遍历器。
  - Map.prototype.values()：返回键值的遍历器。
  - Map.prototype.entries()：返回所有成员的遍历器。
  - Map.prototype.forEach()：遍历 Map 的所有成员。

- 与其他数据结构的互相转换

  - Map转为数组

    - 使用扩展运算符（...）

      ```
      [...map.keys()]
      // [1, 2, 3]
      ```

  - 数组转为Map

    - 将数组传入Map构造函数

  - Map转为对象

  - 对象转为Map

    - 通过Object.entries（）

      ```
      let map = new Map(Object.entries(obj));
      ```

  - Map转为JSON

    - Map的键名都是字符串时，转为对象JSON
    - Map的键名有非字符串时，转为数组JSON

  - JSON转为Map

    - 所有键名都是字符串

##### Promise的含义

- Promise
  - 相当于一个容器，里面保存着某个未来才会结束的事件（通常是一个异步操作）的结果。
  - 从语法来说，Promise是一个对象，从它可以获取异步操作的消息。
  - Promise提供统一的API，各种异步操作都可以用同样的方法进行处理。

- Promise对象有以下两个特点：
  - 对象的状态不受外界影响。
    - 只有异步操作的结果，可以决定当前是哪一种状态，任何其他操作都无法改变这个状态。
    - Promise对象代表一个异步操作，有三种状态：
      - pending（进行中）
      - fulfilled（已成功）
      - rejected（已失败）
  - 一旦状态改变，就不会再变，任何时候都可以得到这个结果。
    - Promise的对象改变，只有两种可能：
      - 从pending变为fulfilled
      - 从pending变为rejected
    - 如果改变已经发生了，再对Promise对象添加回调函数，也会立即得到这个结果。
    - 这与event（事件）不同，事件的特点是，如果你错过了它，再去监听，是得不到结果的。

- Promise的缺点
  - 无法取消Promise，一旦新建它就会立即执行，无法中途取消。
  - 如果不设置回调函数，Promise内部抛出的错误，不会反应到外部。
  - 当处于pending状态时，无法得知目前进展到哪一个阶段。





























































































































